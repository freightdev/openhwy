// Markdown Generation for Data Collection
// Formats scraped data into structured markdown files

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollectedArticle {
    pub title: String,
    pub url: String,
    pub source: String,
    pub category: String,
    pub published_at: Option<String>,
    pub content: String,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct MarkdownDigest {
    pub title: String,
    pub date: DateTime<Utc>,
    pub sections: Vec<MarkdownSection>,
}

#[derive(Debug, Clone)]
pub struct MarkdownSection {
    pub category: String,
    pub articles: Vec<CollectedArticle>,
}

impl MarkdownDigest {
    pub fn new(title: String) -> Self {
        Self {
            title,
            date: Utc::now(),
            sections: Vec::new(),
        }
    }

    pub fn add_section(&mut self, category: String, articles: Vec<CollectedArticle>) {
        self.sections.push(MarkdownSection { category, articles });
    }

    pub fn to_markdown(&self) -> String {
        let mut md = String::new();

        // Header
        md.push_str(&format!("# {}\n\n", self.title));
        md.push_str(&format!("**Generated**: {}  \n", self.date.format("%Y-%m-%d %H:%M:%S UTC")));
        md.push_str(&format!("**Total Articles**: {}  \n\n", self.total_articles()));
        md.push_str("---\n\n");

        // Table of Contents
        md.push_str("## Table of Contents\n\n");
        for (idx, section) in self.sections.iter().enumerate() {
            md.push_str(&format!("{}. [{}](#{})\n",
                idx + 1,
                section.category.replace('_', " ").to_uppercase(),
                section.category.to_lowercase().replace(' ', "-")
            ));
        }
        md.push_str("\n---\n\n");

        // Sections
        for section in &self.sections {
            md.push_str(&section.to_markdown());
        }

        // Footer
        md.push_str("\n---\n\n");
        md.push_str(&format!("*Generated by AI Data Collector at {}*\n",
            self.date.format("%Y-%m-%d %H:%M:%S UTC")));

        md
    }

    fn total_articles(&self) -> usize {
        self.sections.iter().map(|s| s.articles.len()).sum()
    }

    pub fn save_to_file(&self, path: &Path) -> Result<(), std::io::Error> {
        // Create parent directories
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        // Write markdown
        fs::write(path, self.to_markdown())?;

        Ok(())
    }
}

impl MarkdownSection {
    pub fn to_markdown(&self) -> String {
        let mut md = String::new();

        // Section header
        md.push_str(&format!("## {}\n\n", self.category.replace('_', " ").to_uppercase()));
        md.push_str(&format!("*{} articles*\n\n", self.articles.len()));

        // Articles
        for (idx, article) in self.articles.iter().enumerate() {
            md.push_str(&format!("### {}. {}\n\n", idx + 1, article.title));
            md.push_str(&format!("**Source**: {}  \n", article.source));
            md.push_str(&format!("**Category**: {}  \n", article.category));
            md.push_str(&format!("**URL**: <{}>  \n", article.url));

            if let Some(published) = &article.published_at {
                md.push_str(&format!("**Published**: {}  \n", published));
            }

            // Metadata
            if !article.metadata.is_empty() {
                md.push_str("\n**Additional Info**:  \n");
                for (key, value) in &article.metadata {
                    md.push_str(&format!("- **{}**: {}  \n", key, value));
                }
            }

            md.push_str("\n");

            // Content
            if !article.content.is_empty() {
                md.push_str("**Summary**:\n\n");
                md.push_str(&article.content);
                md.push_str("\n\n");
            }

            md.push_str("---\n\n");
        }

        md
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_markdown_generation() {
        let mut digest = MarkdownDigest::new("Daily Trucking Industry Report".to_string());

        let articles = vec![
            CollectedArticle {
                title: "Freight Rates Rise 10% in Q4".to_string(),
                url: "https://example.com/article1".to_string(),
                source: "FreightWaves".to_string(),
                category: "market_rates".to_string(),
                published_at: Some("2025-01-15".to_string()),
                content: "Spot freight rates increased significantly...".to_string(),
                metadata: [("author".to_string(), "John Doe".to_string())].iter().cloned().collect(),
            },
        ];

        digest.add_section("Market Rates".to_string(), articles);

        let markdown = digest.to_markdown();
        assert!(markdown.contains("# Daily Trucking Industry Report"));
        assert!(markdown.contains("## MARKET RATES"));
        assert!(markdown.contains("Freight Rates Rise 10% in Q4"));
    }
}
